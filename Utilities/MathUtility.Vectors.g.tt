<#@ template language="C#" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
#nullable enable

using System;
using System.Numerics;
using Exanite.Core.Numerics;

namespace Exanite.Core.Utilities;

public static partial class M
{
<#
var components = new List<string>() { "X", "Y", "Z", "W" };
for (var componentCount = 2; componentCount <= components.Count; componentCount++)
{
#>
    /// <summary>
    /// Interpolates from one vector to another by <see cref="t"/>.
    /// <see cref="t"/> will be clamped in the range [0, 1]
    /// </summary>
    public static Vector<#= componentCount #> Lerp(Vector<#= componentCount #> from, Vector<#= componentCount #> to, float t)
    {
        t = Clamp01(t);
        return from + (to - from) * t;
    }

    /// <summary>
    /// Interpolates from one vector to another by <see cref="t"/>.
    /// </summary>
    public static Vector<#= componentCount #> LerpUnclamped(Vector<#= componentCount #> from, Vector<#= componentCount #> to, float t)
    {
        return from + (to - from) * t;
    }

    /// <inheritdoc cref="SmoothDamp{T}"/>/>
    public static Vector<#= componentCount #> SmoothDamp(Vector<#= componentCount #> current, Vector<#= componentCount #> target, float smoothTime, float deltaTime, ref Vector<#= componentCount #> currentVelocity, float maxSpeed = float.PositiveInfinity)
    {
        var result = new Vector<#= componentCount #>(<#= string.Join(", ", Enumerable.Range(0, componentCount).Select(index => $"SmoothDamp(current.{components[index]}, target.{components[index]}, smoothTime, deltaTime, ref currentVelocity.{components[index]}, maxSpeed)")) #>);
        currentVelocity = ClampMagnitude(currentVelocity, maxSpeed);

        return result;
    }

    /// <summary>
    /// Clamps the length of the provided vector to between [0, maxLength].
    /// </summary>
    public static Vector<#= componentCount #> ClampMagnitude(Vector<#= componentCount #> value, float maxLength)
    {
        return ClampMagnitude(value, 0, maxLength);
    }

    /// <summary>
    /// Clamps the length of the provided vector to between [minLength, maxLength].
    /// If a zero vector is provided, then the result is a zero vector.
    /// </summary>
    public static Vector<#= componentCount #> ClampMagnitude(Vector<#= componentCount #> value, float minLength, float maxLength)
    {
        return value.AsNormalizedOrDefault() * Clamp(value.Length(), minLength, maxLength);
    }

    /// <summary>
    /// Component-wise clamps the provided vector to the bounds given by <see cref="min"/> and <see cref="max"/>.
    /// </summary>
    public static void Clamp(ref this Vector<#= componentCount #> vector, Vector<#= componentCount #> min, Vector<#= componentCount #> max)
    {
<#
    for (var i = 0; i < componentCount; i++)
    {
#>
        vector.X = Clamp(vector.<#= components[i] #>, min.<#= components[i] #>, max.<#= components[i] #>);
<#
    }
#>
    }

    /// <summary>
    /// Returns the normalized version of the provided vector, or returns zero if the provided vector is zero.
    /// </summary>
    public static Vector<#= componentCount #> AsNormalizedOrDefault(this Vector<#= componentCount #> value)
    {
        return value.AsNormalizedOrDefault(Vector<#= componentCount #>.Zero);
    }

    /// <summary>
    /// Returns the normalized version of the provided vector, or returns the specified default value if the provided vector is zero.
    /// </summary>
    public static Vector<#= componentCount #> AsNormalizedOrDefault(this Vector<#= componentCount #> value, Vector<#= componentCount #> defaultValue)
    {
        return value == Vector<#= componentCount #>.Zero ? defaultValue : Vector<#= componentCount #>.Normalize(value);
    }

    /// <summary>
    /// Checks if two vectors are approximately the same value based on the provided <see cref="tolerance"/>.
    /// </summary>
    public static bool ApproximatelyEquals(Vector<#= componentCount #> a, Vector<#= componentCount #> b, float tolerance = 0.000001f)
    {
        return <#= string.Join(" && ", Enumerable.Range(0, componentCount).Select(index => $"ApproximatelyEquals(a.{components[index]}, b.{components[index]}, tolerance)")) #>;
    }
<#
}
#>
<#
for (var isVectorIntI = 0; isVectorIntI < 2; isVectorIntI++)
{
    var suffix = isVectorIntI == 1 ? "Int" : "";

    for (var fromCount = 2; fromCount <= components.Count; fromCount++)
    {
        for (var toCount = 2; toCount <= components.Count; toCount++)
        {
            if (fromCount == toCount)
            {
                continue;
            }

            var name = "";
            var usedComponentCount = Math.Min(fromCount, toCount);
            for (var usedComponentI = 0; usedComponentI < usedComponentCount; usedComponentI++)
            {
                var component = components[usedComponentI];
                name += usedComponentI == 0 ? component : component.ToLower();
            }

            var isDroppingComponents = toCount < fromCount;
            if (isDroppingComponents)
            {
#>

    /// <summary>
    /// Converts a Vector<#= fromCount #><#= suffix #> to a Vector<#= toCount #><#= suffix #> by dropping components.
    /// </summary>
    public static Vector<#= toCount #><#= suffix #> <#= name #>(this Vector<#= fromCount #><#= suffix #> value)
    {
        return new Vector<#= toCount #><#= suffix #>(<#= string.Join(", ", Enumerable.Range(0, toCount).Select(index => $"value.{components[index]}")) #>);
    }
<#
            }
            else
            {
                var addedComponents = new List<string>()
                {
                    "",
                };

                for (var addedComponentI = fromCount; addedComponentI < toCount; addedComponentI++)
                {
                    var newAddedComponents = new List<string>();
                    foreach (var addedComponent in addedComponents)
                    {
                        for (var componentToAdd = 0; componentToAdd < 2; componentToAdd++)
                        {
                            newAddedComponents.Add(addedComponent + componentToAdd);
                        }
                    }

                    addedComponents = newAddedComponents;
                }

                foreach (var addedComponent in addedComponents)
                {
#>

    /// <summary>
    /// Converts a Vector<#= fromCount #><#= suffix #> to a Vector<#= toCount #><#= suffix #> by adding components.
    /// </summary>
    public static Vector<#= toCount #><#= suffix #> <#= name #><#= addedComponent #>(this Vector<#= fromCount #><#= suffix #> value)
    {
        return new Vector<#= toCount #><#= suffix #>(<#= string.Join(", ", Enumerable.Range(0, fromCount).Select(index => $"value.{components[index]}")) #>, <#= string.Join(", ", addedComponent.Select(c => c)) #>);
    }
<#
                }
            }
        }
    }
}
#>
}
